<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ESL Quiz with Team Minigame</title>
<style>
  body { 
    font-family: 'Comic Sans MS', cursive, sans-serif;
    padding: 0;
    margin: 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    color: #333;
  }
  
  .header {
    background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7);
    background-size: 400% 400%;
    animation: gradientShift 4s ease infinite;
    padding: 20px 0;
    text-align: center;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    margin-bottom: 30px;
  }
  
  @keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }
  
  .header h1 {
    color: white;
    font-size: 3em;
    margin: 0;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
  }
  
  .header .emoji {
    font-size: 1.2em;
    animation: bounce 2s infinite;
  }
  
  @keyframes bounce {
    0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
    40% { transform: translateY(-10px); }
    60% { transform: translateY(-5px); }
  }
  
  .main-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 20px;
  }
  
  #teacherView, #studentView, #minigameView { display: none; }
  
  .card {
    background: white;
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    margin: 20px 0;
    border: 3px solid transparent;
    background-clip: padding-box;
  }
  
  .teacher-card {
    border-image: linear-gradient(45deg, #ff6b6b, #4ecdc4) 1;
  }
  
  .student-card {
    border-image: linear-gradient(45deg, #4ecdc4, #45b7d1) 1;
  }
  
  .minigame-card {
    border-image: linear-gradient(45deg, #96ceb4, #ffeaa7) 1;
  }
  
  .lobby-buttons {
    display: flex;
    gap: 30px;
    justify-content: center;
    margin: 40px 0;
  }
  
  .role-button {
    padding: 20px 40px;
    font-size: 1.5em;
    font-weight: bold;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  
  #teacherBtn {
    background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
    color: white;
  }
  
  #teacherBtn:hover {
    background: linear-gradient(45deg, #ff5252, #ff6b6b);
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(255,107,107,0.4);
  }
  
  #studentBtn {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    color: white;
  }
  
  #studentBtn:hover {
    background: linear-gradient(45deg, #26d0ce, #4ecdc4);
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(78,205,196,0.4);
  }
  
  .choice { 
    padding: 15px 25px; 
    margin: 10px; 
    cursor: pointer; 
    display: block; 
    margin: 10px auto; 
    background: linear-gradient(45deg, #667eea, #764ba2);
    border: 3px solid #fff;
    border-radius: 15px;
    min-width: 250px;
    color: white;
    font-size: 1.1em;
    font-weight: bold;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
  }
  
  .choice:hover {
    background: linear-gradient(45deg, #764ba2, #667eea);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(102,126,234,0.4);
  }
  
  .choice:disabled { 
    background: #ddd;
    cursor: default;
    transform: none;
    box-shadow: none;
    color: #999;
  }
  
  button {
    padding: 12px 25px;
    margin: 8px;
    background: linear-gradient(45deg, #45b7d1, #96ceb4);
    color: white;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    font-size: 1em;
    font-weight: bold;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  }
  
  button:hover {
    background: linear-gradient(45deg, #96ceb4, #45b7d1);
    transform: translateY(-2px);
    box-shadow: 0 6px 18px rgba(69,183,209,0.4);
  }
  
  button:disabled {
    background: #ccc;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }
  
  #feedback {
    font-size: 1.3em;
    font-weight: bold;
    margin: 20px 0;
    min-height: 40px;
    padding: 15px;
    border-radius: 15px;
    background: rgba(255,255,255,0.9);
  }
  
  .error {
    color: #e74c3c;
    background: linear-gradient(45deg, #ffecec, #ffe6e6);
    padding: 15px;
    border-radius: 15px;
    margin: 15px 0;
    border-left: 5px solid #e74c3c;
    box-shadow: 0 4px 12px rgba(231,76,60,0.2);
  }
  
  .success {
    color: #27ae60;
    font-weight: bold;
  }
  
  .warning {
    color: #f39c12;
    font-weight: bold;
  }
  
  .wrong {
    color: #e74c3c;
    font-weight: bold;
  }
  
  #playersList {
    text-align: left;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    padding: 20px;
    border-radius: 15px;
    margin: 15px 0;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
  }
  
  #playersList h3 {
    color: #ffeaa7;
    margin-top: 0;
  }
  
  .connection-status {
    position: fixed;
    top: 15px;
    right: 15px;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    z-index: 1000;
  }
  
  .connected {
    background: linear-gradient(45deg, #00b894, #55efc4);
    color: white;
    box-shadow: 0 4px 12px rgba(0,184,148,0.3);
  }
  
  .disconnected {
    background: linear-gradient(45deg, #fd79a8, #fdcb6e);
    color: white;
    box-shadow: 0 4px 12px rgba(253,121,168,0.3);
  }
  
  /* Minigame Styles */
  .switch {
    display: inline-block;
    margin: 15px;
    padding: 25px 35px;
    background: linear-gradient(45deg, #00cec9, #55efc4);
    color: white;
    border-radius: 20px;
    cursor: pointer;
    font-size: 1.3em;
    font-weight: bold;
    transition: all 0.3s ease;
    border: none;
    min-width: 150px;
    box-shadow: 0 6px 18px rgba(0,206,201,0.3);
  }
  
  .switch:hover {
    background: linear-gradient(45deg, #55efc4, #00cec9);
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 10px 25px rgba(0,206,201,0.5);
  }
  
  .switch:disabled {
    cursor: not-allowed;
    opacity: 0.6;
    transform: none;
  }
  
  .team-info {
    background: white;
    padding: 20px;
    border-radius: 15px;
    margin: 15px 0;
    border-left: 8px solid #007bff;
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
  }
  
  .team-info:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  }
  
  .team-eliminated {
    background: #ffe6e6;
    border-left-color: #dc3545;
    opacity: 0.8;
  }
  
  .team-winner {
    background: linear-gradient(135deg, #d4f4dd, #c8e6c9);
    border-left-color: #28a745;
    box-shadow: 0 5px 20px rgba(40,167,69,0.2);
  }
  
  .representative {
    font-weight: bold;
    color: #007bff;
    background: #e3f2fd;
    padding: 5px 10px;
    border-radius: 10px;
    display: inline-block;
  }
  
  .exploded {
    background: linear-gradient(45deg, #e17055, #d63031) !important;
    animation: explodeShake 0.6s ease-in-out;
  }
  
  .safe {
    background: linear-gradient(45deg, #fdcb6e, #f39c12) !important;
    animation: celebratePulse 0.8s ease-in-out;
  }
  
  @keyframes explodeShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-8px) rotate(-2deg); }
    75% { transform: translateX(8px) rotate(2deg); }
  }
  
  @keyframes celebratePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }
  
  h2 {
    color: #2d3436;
    text-align: center;
    font-size: 2em;
    margin-bottom: 20px;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
  }
  
  .question-display {
    background: linear-gradient(135deg, #74b9ff, #0984e3);
    color: white;
    padding: 25px;
    border-radius: 20px;
    margin: 20px 0;
    box-shadow: 0 8px 25px rgba(116,185,255,0.3);
  }
  
  .question-display h3 {
    margin-top: 0;
    font-size: 1.5em;
    color: #ffeaa7;
  }
  
  .score-display {
    background: linear-gradient(45deg, #a29bfe, #6c5ce7);
    color: white;
    padding: 15px;
    border-radius: 15px;
    text-align: center;
    font-size: 1.2em;
    font-weight: bold;
    margin: 15px 0;
    box-shadow: 0 5px 15px rgba(162,155,254,0.3);
  }
  
  .lobby-description {
    text-align: center;
    color: white;
    font-size: 1.3em;
    margin: 30px 0;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
  }
</style>
</head>
<body>

<div class="connection-status" id="connectionStatus">Connecting...</div>

<div class="header">
  <h1>
    <span class="emoji">üéì</span>
    ESL Quiz Adventure
    <span class="emoji">üéÆ</span>
  </h1>
</div>

<div class="main-container">

<div id="lobby">
  <div class="card">
    <div class="lobby-description">
      <p style="color:black">üåü Welcome to the ESL Quiz Adventure! üåü</p>
      <p style="color:black">Choose your role to begin the learning journey!</p>
    </div>
    
    <div class="lobby-buttons">
      <button id="teacherBtn" class="role-button">
        üë®‚Äçüè´ Teacher
      </button>
      <button id="studentBtn" class="role-button">
        üéí Student
      </button>
    </div>
    
    <div id="connectionError" class="error" style="display: none;"></div>
  </div>
</div>

<div id="teacherView">
  <div class="card teacher-card">
    <h2>üë®‚Äçüè´ Teacher Control Panel</h2>
    <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 20px 0;">
      <button id="startBtn">üöÄ Start New Quiz</button>
      <button id="nextBtn" style="display: none;">‚û°Ô∏è Next Question</button>
      <button id="endBtn" style="display: none;">üèÅ End Quiz</button>
      <button id="startMinigameBtn" style="display: none;">üéÆ Start Minigame</button>
      <button id="nextRoundBtn" style="display: none;">üîÑ Next Round</button>
      <button id="resetBtn" style="display: none;">üîÑ Reset Game</button>
    </div>
    
    <div id="teacherStatus"></div>
    <div id="playersList"></div>
    <div id="currentQuestionDisplay" class="question-display" style="display: none;"></div>
    <div id="teamsDisplay"></div>
  </div>
</div>

<div id="studentView">
  <div class="card student-card">
    <h2 id="studentName">üéí Welcome Student!</h2>
    <div id="waitingMessage" class="lobby-description" style="color:black">Waiting for teacher to start the quiz...</div>
    <div id="questionContainer"></div>
    <div id="feedback"></div>
    <div id="scoreDisplay" class="score-display" style="display: none;"></div>
  </div>
</div>

<div id="minigameView">
  <div class="card minigame-card">
    <h2>üéÆ Team Minigame: Exploding Switches üí£</h2>
    <div id="minigameStatus"></div>
    <div id="teamsInfo"></div>
    <div id="switchContainer" style="text-align: center; margin: 30px 0;"></div>
    <div id="minigameFeedback"></div>
  </div>
</div>

</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { getDatabase, ref, set, update, runTransaction, onValue, off, onDisconnect, get } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";

// ===== Firebase Configuration =====
const firebaseConfig = {
  apiKey: "AIzaSyAwCGVcbFrNIcRtbltP8ENl4Z77IsmzoSo",
  authDomain: "esl-quiz.firebaseapp.com",
  databaseURL: "https://esl-quiz-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "esl-quiz",
  storageBucket: "esl-quiz.firebasestorage.app",
  messagingSenderId: "999634500142",
  appId: "1:999634500142:web:17b206cfaa5a2f6212bdbf"
};

let app, db;
let connectionStatus = false;
let initializationComplete = false;

try {
  app = initializeApp(firebaseConfig);
  db = getDatabase(app);
  console.log("Firebase initialized successfully");
  
  initializationComplete = true;
  
  const connectedRef = ref(db, ".info/connected");
  onValue(connectedRef, (snapshot) => {
    connectionStatus = snapshot.val();
    console.log("Connection status:", connectionStatus);
    updateConnectionStatus();
  }, (error) => {
    console.error("Connection monitoring error:", error);
    showConnectionError("Connection monitoring failed: " + error.message);
    connectionStatus = false;
    initializationComplete = true;
    updateConnectionStatus();
  });
  
} catch (error) {
  console.error("Firebase initialization error:", error);
  showConnectionError("Failed to initialize Firebase: " + error.message);
  initializationComplete = true;
  updateConnectionStatus();
}

// Force initialization after timeout
setTimeout(() => {
  if (!initializationComplete) {
    console.log("Forcing initialization completion after timeout");
    initializationComplete = true;
    updateConnectionStatus();
  }
}, 3000);

function updateConnectionStatus() {
  const statusEl = document.getElementById("connectionStatus");
  const teacherBtn = document.getElementById("teacherBtn");
  const studentBtn = document.getElementById("studentBtn");
  const connectionError = document.getElementById("connectionError");
  
  if (!initializationComplete) {
    statusEl.textContent = "üîÑ Initializing...";
    statusEl.className = "connection-status disconnected";
    teacherBtn.disabled = true;
    studentBtn.disabled = true;
    return;
  }
  
  if (connectionStatus) {
    statusEl.textContent = "üü¢ Connected";
    statusEl.className = "connection-status connected";
    connectionError.style.display = "none";
    teacherBtn.disabled = false;
    studentBtn.disabled = false;
  } else {
    statusEl.textContent = "üü° Offline Mode";
    statusEl.className = "connection-status disconnected";
    connectionError.innerHTML = "‚ö†Ô∏è Firebase offline - using local mode for testing";
    connectionError.style.display = "block";
    connectionError.style.backgroundColor = "#fff3cd";
    connectionError.style.color = "#856404";
    teacherBtn.disabled = false;
    studentBtn.disabled = false;
  }
}

function showConnectionError(message) {
  const errorEl = document.getElementById("connectionError");
  errorEl.textContent = message;
  errorEl.style.display = "block";
  console.error("Connection error:", message);
}

// Questions
const questions = [
  { text: "What is the past tense of 'go'?", choices: ["goed","went","goes","going"], correct: 1 },
  { text: "What is the past tense of 'eat'?", choices: ["ate","eated","eaten","eat"], correct: 0 },
  { text: "What is the past tense of 'drink'?", choices: ["drink","drunk","drank","drinks"], correct: 2 },
  { text: "Which is correct?", choices: ["I have went","I have gone","I have go","I have going"], correct: 1 },
  { text: "Choose the correct sentence:", choices: ["She don't like pizza","She doesn't like pizza","She no like pizza","She not like pizza"], correct: 1 }
];

// DOM elements
const lobby = document.getElementById("lobby");
const teacherView = document.getElementById("teacherView");
const studentView = document.getElementById("studentView");
const minigameView = document.getElementById("minigameView");
const startBtn = document.getElementById("startBtn");
const nextBtn = document.getElementById("nextBtn");
const endBtn = document.getElementById("endBtn");
const startMinigameBtn = document.getElementById("startMinigameBtn");
const nextRoundBtn = document.getElementById("nextRoundBtn");
const resetBtn = document.getElementById("resetBtn");
const teacherStatus = document.getElementById("teacherStatus");
const questionContainer = document.getElementById("questionContainer");
const feedbackEl = document.getElementById("feedback");
const studentNameEl = document.getElementById("studentName");
const waitingMessage = document.getElementById("waitingMessage");
const scoreDisplay = document.getElementById("scoreDisplay");
const playersList = document.getElementById("playersList");
const currentQuestionDisplay = document.getElementById("currentQuestionDisplay");
const teamsDisplay = document.getElementById("teamsDisplay");

// Minigame elements
const minigameStatus = document.getElementById("minigameStatus");
const teamsInfo = document.getElementById("teamsInfo");
const switchContainer = document.getElementById("switchContainer");
const minigameFeedback = document.getElementById("minigameFeedback");

// State
let role = null;
let playerName = "";
let currentQuestionIndex = 0;
let questionAnswered = false;
let gameListeners = [];
let currentView = "lobby";

const GAME_ROOM = "game1";

// ===== Utility Functions =====
function safeFirebaseOperation(operation, errorMessage) {
  if (!connectionStatus) {
    throw new Error("Not connected to database");
  }
  return operation().catch(error => {
    console.error(errorMessage, error);
    throw new Error(`${errorMessage}: ${error.message}`);
  });
}

function cleanupListeners() {
  gameListeners.forEach(({ ref: dbRef, callback }) => {
    off(dbRef, 'value', callback);
  });
  gameListeners = [];
}

function createTeams(players, scores) {
  const playerList = Object.keys(players).filter(name => players[name].online);
  const playerScores = playerList.map(name => ({
    name,
    score: scores[name] || 0
  })).sort((a, b) => b.score - a.score);

  const teams = [
    { name: "Team Alpha", members: [], eliminated: false, color: "#007bff" },
    { name: "Team Beta", members: [], eliminated: false, color: "#28a745" },
    { name: "Team Gamma", members: [], eliminated: false, color: "#dc3545" },
    { name: "Team Delta", members: [], eliminated: false, color: "#ffc107" }
  ];

  playerScores.forEach((player, index) => {
    const teamIndex = Math.floor(index / Math.ceil(playerScores.length / 4)) % 4;
    teams[teamIndex].members.push(player.name);
  });

  return teams.filter(team => team.members.length > 0);
}

function selectRandomRepresentative(teamMembers, players) {
  const onlineMembers = teamMembers.filter(member => players[member]?.online);
  if (onlineMembers.length === 0) return null;
  return onlineMembers[Math.floor(Math.random() * onlineMembers.length)];
}

// ===== View Management =====
function showView(viewName) {
  lobby.style.display = "none";
  teacherView.style.display = "none";
  studentView.style.display = "none";
  minigameView.style.display = "none";
  
  currentView = viewName;
  switch(viewName) {
    case "teacher":
      teacherView.style.display = "block";
      break;
    case "student":
      studentView.style.display = "block";
      break;
    case "minigame":
      minigameView.style.display = "block";
      break;
    default:
      lobby.style.display = "block";
  }
}

// ===== Role Selection =====
document.getElementById("teacherBtn").onclick = () => selectRole("teacher");
document.getElementById("studentBtn").onclick = () => selectRole("student");

// Teacher password - change this to whatever you want
const TEACHER_PASSWORD = "teacher123";

async function selectRole(r) {
  console.log("Role selected:", r, "Init complete:", initializationComplete, "Connection:", connectionStatus);
  
  if (!initializationComplete) {
    showConnectionError("System still initializing. Please wait a moment and try again.");
    return;
  }
  
  // Check password for teacher access
  if (r === "teacher") {
    const enteredPassword = prompt("Enter teacher password:");
    if (enteredPassword !== TEACHER_PASSWORD) {
      alert("Incorrect password! Access denied.");
      return;
    }
  }
  
  role = r;
  
  try {
    if (role === "teacher") {
      showView("teacher");
      if (connectionStatus) {
        await setupTeacher();
      } else {
        setupTeacherOffline();
      }
    } else {
      showView("student");
      if (connectionStatus) {
        await setupStudent();
      } else {
        setupStudentOffline();
      }
    }
  } catch (error) {
    console.error("Setup error:", error);
    if (role === "teacher") {
      teacherStatus.innerHTML = `<div class="error">Setup failed: ${error.message}<br><small>Try refreshing the page or check your Firebase configuration.</small></div>`;
    } else {
      feedbackEl.innerHTML = `<div class="error">Setup failed: ${error.message}<br><small>Try refreshing the page.</small></div>`;
    }
  }
}

// ===== Offline Functions =====
function setupTeacherOffline() {
  teacherStatus.innerHTML = '<div class="warning">‚ö†Ô∏è Running in offline mode - changes will not sync between users</div>';
  
  startBtn.onclick = () => {
    teacherStatus.innerHTML = '<div class="success">Quiz started! (Offline mode)</div>';
    currentQuestionIndex = 0;
    startBtn.style.display = "none";
    nextBtn.style.display = "inline-block";
    endBtn.style.display = "inline-block";
    resetBtn.style.display = "inline-block";
    
    showCurrentQuestion();
  };

  nextBtn.onclick = () => {
    currentQuestionIndex++;
    if (currentQuestionIndex < questions.length) {
      teacherStatus.innerHTML = `<div class="success">Question ${currentQuestionIndex + 1} of ${questions.length}</div>`;
      showCurrentQuestion();
    } else {
      endQuizOffline();
    }
  };

  endBtn.onclick = () => {
    endQuizOffline();
  };

  resetBtn.onclick = () => {
    teacherStatus.innerHTML = '<div class="success">Game reset! (Offline mode)</div>';
    showQuizControls();
    currentQuestionDisplay.innerHTML = '<p>No quiz in progress.</p>';
  };
}

function showCurrentQuestion() {
  if (questions[currentQuestionIndex]) {
    const q = questions[currentQuestionIndex];
    const display = document.getElementById("currentQuestionDisplay");
    display.style.display = "block";
    display.innerHTML = `
      <h3>üìö Current Question (${currentQuestionIndex + 1}/${questions.length})</h3>
      <p><strong>${q.text}</strong></p>
      <ul style="text-align: left; margin: 15px 0;">
        ${q.choices.map((choice, i) => `<li${i === q.correct ? ' style="color: #ffeaa7; font-weight: bold;"' : ''}>${choice}${i === q.correct ? ' ‚úÖ' : ''}</li>`).join('')}
      </ul>
    `;
  }
}

function setupStudentOffline() {
  playerName = prompt("Enter your name:") || "Player" + Math.floor(Math.random()*1000);
  studentNameEl.textContent = "Welcome, " + playerName + "!";
  feedbackEl.innerHTML = '<div class="warning">‚ö†Ô∏è Running in offline mode - this is just for testing the interface</div>';
  
  setTimeout(() => {
    if (questions[0]) {
      renderQuestionOffline(questions[0]);
    }
  }, 1000);
}

function renderQuestionOffline(q) {
  questionContainer.innerHTML = `<h3>Sample Question: ${q.text}</h3>`;
  feedbackEl.innerHTML = '<p>This is offline mode - click any answer to test</p>';
  
  q.choices.forEach((choice, i) => {
    const btn = document.createElement("button");
    btn.textContent = choice;
    btn.className = "choice";
    btn.onclick = () => {
      const isCorrect = i === q.correct;
      if (isCorrect) {
        feedbackEl.innerHTML = '<span class="success">‚úÖ Correct! (Offline test mode)</span>';
      } else {
        feedbackEl.innerHTML = `<span class="wrong">‚ùå Wrong! Correct answer: <strong>${q.choices[q.correct]}</strong> (Offline test mode)</span>`;
      }
    };
    questionContainer.appendChild(btn);
  });
}

function endQuizOffline() {
  teacherStatus.innerHTML = '<div class="success">Quiz ended! (Offline mode)</div>';
  nextBtn.style.display = "none";
  endBtn.style.display = "none";
  currentQuestionDisplay.innerHTML = '<h3>Quiz Complete! üéâ</h3><p>In online mode, this would lead to the team minigame.</p>';
}

function showQuizControls() {
  startBtn.style.display = "inline-block";
  nextBtn.style.display = "none";
  endBtn.style.display = "none";
  startMinigameBtn.style.display = "none";
  nextRoundBtn.style.display = "none";
  resetBtn.style.display = "none";
}

// ===== Teacher Functions =====
async function setupTeacher() {
  const teacherRef = ref(db, `${GAME_ROOM}/teacher`);
  await set(teacherRef, { present: true, timestamp: Date.now() });
  onDisconnect(teacherRef).remove();
  
  setupTeacherButtons();
  watchGameState();
  
  const gameRef = ref(db, GAME_ROOM);
  const snapshot = await get(gameRef);
  if (snapshot.exists()) {
    const data = snapshot.val();
    updateTeacherDisplay(data);
    
    if (data.state === "minigame") {
      showMinigameControls();
    }
  }
}

function setupTeacherButtons() {
  startBtn.onclick = async () => {
    try {
      const gameRef = ref(db, GAME_ROOM);
      const snapshot = await get(gameRef);
      const existingData = snapshot.val() || {};
      
      await safeFirebaseOperation(async () => {
        await set(ref(db, GAME_ROOM), {
          state: "quiz",
          currentQuestion: 0,
          scores: existingData.scores || {},
          players: existingData.players || {},
          teacher: { present: true, timestamp: Date.now() }
        });
      }, "Failed to start quiz");
      
      currentQuestionIndex = 0;
      teacherStatus.innerHTML = '<div class="success">Quiz started! Question 1 of ' + questions.length + '</div>';
      startBtn.style.display = "none";
      nextBtn.style.display = "inline-block";
      endBtn.style.display = "inline-block";
      resetBtn.style.display = "inline-block";
    } catch (error) {
      teacherStatus.innerHTML = `<div class="error">Error starting quiz: ${error.message}</div>`;
    }
  };

  nextBtn.onclick = async () => {
    try {
      const gameRef = ref(db, GAME_ROOM);
      const nextQuestion = currentQuestionIndex + 1;
      
      if (nextQuestion < questions.length) {
        await safeFirebaseOperation(async () => {
          await update(gameRef, { currentQuestion: nextQuestion });
        }, "Failed to advance question");
        
        teacherStatus.innerHTML = `<div class="success">Moved to question ${nextQuestion + 1} of ${questions.length}</div>`;
      } else {
        await endQuiz();
      }
    } catch (error) {
      teacherStatus.innerHTML = `<div class="error">Error advancing question: ${error.message}</div>`;
    }
  };

  endBtn.onclick = async () => {
    await endQuiz();
  };

  startMinigameBtn.onclick = async () => {
    await startMinigame();
  };

  nextRoundBtn.onclick = async () => {
    await nextMinigameRound();
  };

  resetBtn.onclick = async () => {
    try {
      await safeFirebaseOperation(async () => {
        await set(ref(db, GAME_ROOM), {
          state: "lobby",
          teacher: { present: true, timestamp: Date.now() }
        });
      }, "Failed to reset game");
      
      teacherStatus.innerHTML = '<div class="success">Game reset! Students can join again.</div>';
      showQuizControls();
    } catch (error) {
      teacherStatus.innerHTML = `<div class="error">Error resetting game: ${error.message}</div>`;
    }
  };
}

function showMinigameControls() {
  startBtn.style.display = "none";
  nextBtn.style.display = "none";
  endBtn.style.display = "none";
  startMinigameBtn.style.display = "none";
  nextRoundBtn.style.display = "inline-block";
  resetBtn.style.display = "inline-block";
}

async function endQuiz() {
  try {
    await safeFirebaseOperation(async () => {
      await update(ref(db, GAME_ROOM), { state: "results" });
    }, "Failed to end quiz");
    
    teacherStatus.innerHTML = '<div class="success">Quiz ended! Ready to start minigame.</div>';
    nextBtn.style.display = "none";
    endBtn.style.display = "none";
    startMinigameBtn.style.display = "inline-block";
  } catch (error) {
    teacherStatus.innerHTML = `<div class="error">Error ending quiz: ${error.message}</div>`;
  }
}

async function startMinigame() {
  try {
    const gameRef = ref(db, GAME_ROOM);
    const snapshot = await get(gameRef);
    const data = snapshot.val();
    
    if (!data || !data.players || !data.scores) {
      throw new Error("No game data found");
    }
    
    const teams = createTeams(data.players, data.scores);
    const aliveTeams = teams.filter(team => !team.eliminated);
    const totalSwitches = aliveTeams.length + 2;
    const bombIndex = Math.floor(Math.random() * totalSwitches);
    
    await safeFirebaseOperation(async () => {
      await update(gameRef, { 
        state: "minigame",
        teams: teams,
        minigameRound: 1,
        totalSwitches: totalSwitches,
        bombIndex: bombIndex,
        teamChoices: {},
        roundPhase: "choosing",
        revealStartTime: null
      });
    }, "Failed to start minigame");
    
    teacherStatus.innerHTML = '<div class="success">Minigame started! Teams choose switches simultaneously.</div>';
    showMinigameControls();
  } catch (error) {
    teacherStatus.innerHTML = `<div class="error">Error starting minigame: ${error.message}</div>`;
  }
}

async function nextMinigameRound() {
  try {
    const gameRef = ref(db, GAME_ROOM);
    const snapshot = await get(gameRef);
    const data = snapshot.val();
    
    if (!data || !data.teams) {
      throw new Error("No minigame data found");
    }
    
    const aliveTeams = data.teams.filter(team => !team.eliminated);
    if (aliveTeams.length <= 1) {
      teacherStatus.innerHTML = '<div class="warning">Game is already finished!</div>';
      return;
    }
    
    if (data.roundPhase === "choosing") {
      const teamChoices = data.teamChoices || {};
      const teamsWithChoices = Object.keys(teamChoices).length;
      const aliveTeamsCount = aliveTeams.length;
      
      if (teamsWithChoices >= aliveTeamsCount) {
        await safeFirebaseOperation(async () => {
          await update(gameRef, {
            roundPhase: "reveal",
            revealStartTime: Date.now()
          });
        }, "Failed to start reveal");
        
        teacherStatus.innerHTML = '<div class="success">Revealing results...</div>';
        
        setTimeout(async () => {
          await processRoundResults();
        }, 3000);
        
      } else {
        teacherStatus.innerHTML = `<div class="warning">Waiting for ${aliveTeamsCount - teamsWithChoices} more teams to choose...</div>`;
      }
    } else if (data.roundPhase === "reveal" || data.roundPhase === "results") {
      await startNewRound();
    }
  } catch (error) {
    teacherStatus.innerHTML = `<div class="error">Error managing round: ${error.message}</div>`;
  }
}

async function startNewRound() {
  try {
    const gameRef = ref(db, GAME_ROOM);
    const snapshot = await get(gameRef);
    const data = snapshot.val();
    
    const aliveTeams = data.teams.filter(team => !team.eliminated);
    const totalSwitches = aliveTeams.length + 2;
    const bombIndex = Math.floor(Math.random() * totalSwitches);
    
    await safeFirebaseOperation(async () => {
      await update(gameRef, {
        totalSwitches: totalSwitches,
        bombIndex: bombIndex,
        teamChoices: {},
        minigameRound: (data.minigameRound || 1) + 1,
        roundPhase: "choosing",
        revealStartTime: null
      });
    }, "Failed to start new round");
    
    teacherStatus.innerHTML = '<div class="success">New round started!</div>';
  } catch (error) {
    teacherStatus.innerHTML = `<div class="error">Error starting new round: ${error.message}</div>`;
  }
}

async function processRoundResults() {
  try {
    const gameRef = ref(db, GAME_ROOM);
    const snapshot = await get(gameRef);
    const data = snapshot.val();
    
    if (!data || !data.teamChoices) return;
    
    const eliminatedTeamIndexes = [];
    Object.entries(data.teamChoices).forEach(([teamIndex, choice]) => {
      if (choice.switchIndex === data.bombIndex) {
        eliminatedTeamIndexes.push(parseInt(teamIndex));
      }
    });
    
    const updatedTeams = [...data.teams];
    eliminatedTeamIndexes.forEach(teamIndex => {
      updatedTeams[teamIndex].eliminated = true;
    });
    
    await safeFirebaseOperation(async () => {
      await update(gameRef, {
        teams: updatedTeams,
        roundPhase: "results"
      });
    }, "Failed to update elimination results");
    
    if (eliminatedTeamIndexes.length > 0) {
      const eliminatedNames = eliminatedTeamIndexes.map(i => data.teams[i].name).join(', ');
      teacherStatus.innerHTML = `<div class="warning">${eliminatedNames} eliminated! Click "Next Round" to continue.</div>`;
    } else {
      teacherStatus.innerHTML = '<div class="success">All teams survived! Click "Next Round" to continue.</div>';
    }
    
  } catch (error) {
    teacherStatus.innerHTML = `<div class="error">Error processing results: ${error.message}</div>`;
  }
}

function watchGameState() {
  const gameRef = ref(db, GAME_ROOM);
  const callback = (snapshot) => {
    const data = snapshot.val();
    if (data) {
      currentQuestionIndex = data.currentQuestion || 0;
      updateTeacherDisplay(data);
      
      if (data.state === "minigame" && currentView !== "minigame") {
        updateMinigameDisplay(data);
      }
    }
  };
  
  onValue(gameRef, callback);
  gameListeners.push({ ref: gameRef, callback });
}

function updateTeacherDisplay(data) {
  if (data.players && Object.keys(data.players).length > 0) {
    let playersHtml = '<h3>üéì Connected Students</h3><ul style="list-style: none; padding: 0;">';
    Object.entries(data.players).forEach(([player, info]) => {
      const score = data.scores?.[player] || 0;
      const status = info.online ? 'üü¢' : 'üî¥';
      playersHtml += `<li style="margin: 8px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 8px;">${status} <strong>${player}</strong>: ${score} points</li>`;
    });
    playersHtml += '</ul>';
    playersList.innerHTML = playersHtml;
  } else {
    playersList.innerHTML = '<p style="color: #ffeaa7;">üìã No students connected yet.</p>';
  }

  if (data.state === "quiz" && questions[currentQuestionIndex]) {
    const q = questions[currentQuestionIndex];
    const display = document.getElementById("currentQuestionDisplay");
    display.style.display = "block";
    display.innerHTML = `
      <h3>üìö Current Question (${currentQuestionIndex + 1}/${questions.length})</h3>
      <p><strong>${q.text}</strong></p>
      <ul style="text-align: left; margin: 15px 0;">
        ${q.choices.map((choice, i) => `<li${i === q.correct ? ' style="color: #ffeaa7; font-weight: bold;"' : ''}>${choice}${i === q.correct ? ' ‚úÖ' : ''}</li>`).join('')}
      </ul>
    `;
  } else if (data.state === "results") {
    const display = document.getElementById("currentQuestionDisplay");
    display.style.display = "block";
    display.innerHTML = '<h3>üéâ Quiz Complete!</h3><p>Ready to start the team minigame!</p>';
  } else if (data.state === "minigame") {
    document.getElementById("currentQuestionDisplay").style.display = "none";
    updateTeamsDisplay(data);
  } else {
    document.getElementById("currentQuestionDisplay").style.display = "none";
  }
}

function updateTeamsDisplay(data) {
  if (!data.teams) return;
  
  let teamsHtml = '<h3>Teams:</h3>';
  data.teams.forEach((team, index) => {
    const teamClass = team.eliminated ? 'team-eliminated' : '';
    
    teamsHtml += `
      <div class="team-info ${teamClass}" style="border-left-color: ${team.color}">
        <h4>${team.name} ${team.eliminated ? 'üíÄ' : ''}</h4>
        <p>Members: ${team.members.join(', ')}</p>
      </div>
    `;
  });
  
  teamsDisplay.innerHTML = teamsHtml;
}

function updateMinigameDisplay(data) {
  if (!data.teams) return;
  
  updateTeamsDisplay(data);
  
  const aliveTeams = data.teams.filter(t => !t.eliminated);
  if (aliveTeams.length === 1) {
    teacherStatus.innerHTML = `<div class="success">üéâ ${aliveTeams[0].name} wins the minigame!</div>`;
    return;
  }

  const teamChoices = data.teamChoices || {};
  const choicesMade = Object.keys(teamChoices).length;
  const totalAliveTeams = aliveTeams.length;
  
  if (data.roundPhase === "choosing") {
    if (choicesMade === 0) {
      teacherStatus.innerHTML = `<div class="warning">Round ${data.minigameRound || 1}: Teams are choosing switches...</div>`;
    } else if (choicesMade < totalAliveTeams) {
      teacherStatus.innerHTML = `<div class="warning">Round ${data.minigameRound || 1}: ${choicesMade}/${totalAliveTeams} teams have chosen. Click "Next Round" when ready to reveal.</div>`;
    } else {
      teacherStatus.innerHTML = `<div class="success">All teams have chosen! Click "Next Round" to reveal results.</div>`;
    }
  } else if (data.roundPhase === "reveal") {
    teacherStatus.innerHTML = `<div class="warning">üé≠ Revealing results...</div>`;
  } else if (data.roundPhase === "results") {
    let eliminatedTeams = [];
    Object.entries(teamChoices).forEach(([teamIndex, choice]) => {
      if (choice.switchIndex === data.bombIndex) {
        eliminatedTeams.push(data.teams[parseInt(teamIndex)].name);
      }
    });
    
    if (eliminatedTeams.length > 0) {
      teacherStatus.innerHTML = `<div class="error">üí• ${eliminatedTeams.join(', ')} eliminated! Click "Next Round" for new round.</div>`;
    } else {
      teacherStatus.innerHTML = `<div class="success">‚úÖ All teams survived! Click "Next Round" for new round.</div>`;
    }
  }
}

// ===== Student Functions =====
async function setupStudent() {
  playerName = prompt("Enter your name:") || "Player" + Math.floor(Math.random()*1000);
  studentNameEl.textContent = "Welcome, " + playerName + "!";
  
  try {
    const playerRef = ref(db, `${GAME_ROOM}/players/${playerName}`);
    await safeFirebaseOperation(async () => {
      await set(playerRef, { online: true, joinedAt: Date.now() });
      await set(ref(db, `${GAME_ROOM}/scores/${playerName}`), 0);
    }, "Failed to join game");
    
    onDisconnect(playerRef).update({ online: false });
    watchStudentGameState();
    
  } catch (error) {
    feedbackEl.innerHTML = `<div class="error">Failed to join game: ${error.message}</div>`;
  }
}

function watchStudentGameState() {
  const gameRef = ref(db, GAME_ROOM);
  const callback = (snapshot) => {
    const data = snapshot.val();
    if (!data) {
      waitingMessage.innerHTML = "Waiting for teacher to set up the game...";
      waitingMessage.style.display = "block";
      return;
    }

    if (data.state === "quiz") {
      if (currentView !== "student") showView("student");
      
      waitingMessage.style.display = "none";
      
      if (data.currentQuestion !== currentQuestionIndex || !questionAnswered) {
        currentQuestionIndex = data.currentQuestion;
        if (questions[currentQuestionIndex]) {
          renderQuestion(questions[currentQuestionIndex]);
        }
      }
    } else if (data.state === "results") {
      showQuizResults(data);
    } else if (data.state === "minigame") {
      if (currentView !== "minigame") showView("minigame");
      updateStudentMinigameView(data);
    } else {
      if (currentView !== "student") showView("student");
      waitingMessage.style.display = "block";
      waitingMessage.innerHTML = "Waiting for teacher to start the quiz...";
      questionContainer.innerHTML = "";
      feedbackEl.textContent = "";
    }
    
    updateStudentDisplay(data);
  };
  
  onValue(gameRef, callback);
  gameListeners.push({ ref: gameRef, callback });
}

function updateStudentDisplay(data) {
  if (currentView === "student" && data && data.scores) {
    const score = data.scores[playerName] || 0;
    const totalAnswered = Math.min(currentQuestionIndex + (questionAnswered ? 1 : 0), questions.length);
    const display = document.getElementById("scoreDisplay");
    display.style.display = "block";
    display.innerHTML = `üéØ Your Score: ${score}/${totalAnswered}`;
  }
}

function renderQuestion(q) {
  if (!q) return;
  
  questionAnswered = false;
  questionContainer.innerHTML = `<h3>Question ${currentQuestionIndex + 1}: ${q.text}</h3>`;
  feedbackEl.textContent = "";
  
  q.choices.forEach((choice, i) => {
    const btn = document.createElement("button");
    btn.textContent = choice;
    btn.className = "choice";
    btn.onclick = () => handleAnswer(i, q.correct);
    questionContainer.appendChild(btn);
  });
}

async function handleAnswer(choiceIndex, correctIndex) {
  if (questionAnswered) return;
  questionAnswered = true;

  const buttons = questionContainer.querySelectorAll('.choice');
  buttons.forEach(btn => btn.disabled = true);

  const isCorrect = choiceIndex === correctIndex;
  
  try {
    await safeFirebaseOperation(async () => {
      const scoreRef = ref(db, `${GAME_ROOM}/scores/${playerName}`);
      await runTransaction(scoreRef, (currentScore) => {
        return (currentScore || 0) + (isCorrect ? 1 : 0);
      });
    }, "Failed to update score");

    if (isCorrect) {
      feedbackEl.innerHTML = '<span class="success">‚úÖ Correct! Well done!</span>';
    } else {
      feedbackEl.innerHTML = `<span class="wrong">‚ùå Wrong! The correct answer was: <strong>${questions[currentQuestionIndex].choices[correctIndex]}</strong></span>`;
    }
    
    setTimeout(() => {
      if (currentQuestionIndex < questions.length - 1) {
        feedbackEl.innerHTML += '<br><em>Waiting for teacher to continue...</em>';
      }
    }, 2000);
    
  } catch (error) {
    feedbackEl.innerHTML = `<div class="error">Error submitting answer: ${error.message}</div>`;
  }
}

function showQuizResults(data) {
  questionContainer.innerHTML = "<h2>Quiz Finished! üéâ</h2>";
  const finalScore = data.scores?.[playerName] || 0;
  const totalQuestions = questions.length;
  const percentage = Math.round((finalScore / totalQuestions) * 100);
  
  let message = `<p>Your final score: ${finalScore}/${totalQuestions} (${percentage}%)</p>`;
  
  if (percentage >= 80) {
    message += "<p>üåü Excellent work!</p>";
  } else if (percentage >= 60) {
    message += "<p>üëç Good job!</p>";
  } else {
    message += "<p>üìö Keep practicing!</p>";
  }
  
  if (data.scores) {
    const sortedScores = Object.entries(data.scores)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5);
    
    message += "<h3>Top Scores:</h3><ol>";
    sortedScores.forEach(([name, score]) => {
      const highlight = name === playerName ? ' style="background-color: #fff3cd;"' : '';
      message += `<li${highlight}>${name}: ${score}/${totalQuestions}</li>`;
    });
    message += "</ol>";
  }
  
  message += "<p><em>Get ready for the team minigame!</em></p>";
  feedbackEl.innerHTML = message;
}

function updateStudentMinigameView(data) {
  if (!data.teams) return;
  
  let playerTeam = null;
  let playerTeamIndex = -1;
  for (let i = 0; i < data.teams.length; i++) {
    if (data.teams[i].members.includes(playerName)) {
      playerTeam = data.teams[i];
      playerTeamIndex = i;
      break;
    }
  }
  
  let teamsHtml = '<h3>Teams & Their Choices:</h3>';
  const teamChoices = data.teamChoices || {};
  
  data.teams.forEach((team, index) => {
    const isPlayerTeam = index === playerTeamIndex;
    const hasChosen = teamChoices[index] !== undefined;
    const teamClass = team.eliminated ? 'team-eliminated' : (isPlayerTeam ? 'team-winner' : '');
    
    let choiceInfo = '';
    if (data.roundPhase === "reveal" || data.roundPhase === "results") {
      if (hasChosen) {
        const choice = teamChoices[index];
        const isBomb = choice.switchIndex === data.bombIndex;
        choiceInfo = `<p>Chose: Switch ${choice.switchIndex + 1} ${isBomb ? 'üí•' : '‚úÖ'}</p>`;
      }
    } else if (hasChosen) {
      choiceInfo = '<p>‚úÖ Choice made!</p>';
    } else if (!team.eliminated) {
      choiceInfo = '<p>‚è≥ Choosing...</p>';
    }
    
    teamsHtml += `
      <div class="team-info ${teamClass}" style="border-left-color: ${team.color}">
        <h4>${team.name} ${team.eliminated ? 'üíÄ Eliminated' : ''} ${isPlayerTeam ? '‚Üê Your Team' : ''}</h4>
        <p>Members: ${team.members.join(', ')}</p>
        ${choiceInfo}
      </div>
    `;
  });
  teamsInfo.innerHTML = teamsHtml;
  
  const aliveTeams = data.teams.filter(t => !t.eliminated);
  
  if (aliveTeams.length === 1) {
    if (playerTeam && !playerTeam.eliminated) {
      minigameStatus.innerHTML = '<h3>üéâ Your team won the minigame! üéâ</h3>';
    } else {
      minigameStatus.innerHTML = `<h3>Game Over! ${aliveTeams[0].name} wins!</h3>`;
    }
    switchContainer.innerHTML = '';
    minigameFeedback.innerHTML = '';
    return;
  }

  if (playerTeam && playerTeam.eliminated) {
    minigameStatus.innerHTML = '<h3>üíÄ Your team has been eliminated!</h3>';
    switchContainer.innerHTML = '<p>Watch the remaining teams battle it out...</p>';
    minigameFeedback.innerHTML = '';
    return;
  }

  const hasPlayerChosen = teamChoices[playerTeamIndex] !== undefined;
  
  if (data.roundPhase === "choosing") {
    if (hasPlayerChosen) {
      minigameStatus.innerHTML = `<h3>‚úÖ Your choice is locked in!</h3>`;
      minigameFeedback.innerHTML = '<p>Waiting for other teams to choose...</p>';
      switchContainer.innerHTML = `<p>You chose Switch ${teamChoices[playerTeamIndex].switchIndex + 1}</p>`;
    } else {
      minigameStatus.innerHTML = `<h3>üéØ Round ${data.minigameRound || 1}: Choose Your Switch!</h3>`;
      minigameFeedback.innerHTML = `<p>Choose wisely! ${data.totalSwitches} switches available, one contains a bomb üí£</p>`;
      renderMinigameSwitches(data);
    }
  } else if (data.roundPhase === "reveal") {
    minigameStatus.innerHTML = `<h3>üé≠ Results Revealing...</h3>`;
    minigameFeedback.innerHTML = '<p>Finding out who got the bomb...</p>';
    showMinigameReveal(data);
  } else if (data.roundPhase === "results") {
    const playerChoice = teamChoices[playerTeamIndex];
    const playerGotBomb = playerChoice && playerChoice.switchIndex === data.bombIndex;
    
    if (playerGotBomb) {
      minigameStatus.innerHTML = '<h3>üí• Your team got the bomb!</h3>';
      minigameFeedback.innerHTML = '<p style="color: #dc3545;">Better luck next time!</p>';
    } else {
      minigameStatus.innerHTML = '<h3>‚úÖ Your team survived!</h3>';
      minigameFeedback.innerHTML = '<p style="color: #28a745;">Safe for another round!</p>';
    }
    
    showMinigameReveal(data);
  }
}

function renderMinigameSwitches(data) {
  switchContainer.innerHTML = '';
  
  for (let i = 0; i < data.totalSwitches; i++) {
    const switchBtn = document.createElement("button");
    switchBtn.className = "switch";
    switchBtn.textContent = `Switch ${i + 1}`;
    switchBtn.onclick = () => handleSwitchChoice(i, data);
    switchContainer.appendChild(switchBtn);
  }
}

function showMinigameReveal(data) {
  switchContainer.innerHTML = '';
  const teamChoices = data.teamChoices || {};
  
  for (let i = 0; i < data.totalSwitches; i++) {
    const switchBtn = document.createElement("button");
    switchBtn.className = "switch";
    switchBtn.disabled = true;
    
    const teamThatChose = Object.entries(teamChoices).find(([teamIndex, choice]) => choice.switchIndex === i);
    const isBomb = i === data.bombIndex;
    
    if (teamThatChose) {
      const teamIndex = teamThatChose[0];
      const team = data.teams[parseInt(teamIndex)];
      
      if (isBomb) {
        switchBtn.className = "switch exploded";
        switchBtn.textContent = `üí• ${team.name}`;
      } else {
        switchBtn.className = "switch safe";
        switchBtn.textContent = `‚úÖ ${team.name}`;
      }
    } else {
      switchBtn.textContent = `Switch ${i + 1}`;
      if (isBomb) {
        switchBtn.style.backgroundColor = "#ffcccc";
        switchBtn.textContent += " (üí£)";
      }
    }
    
    switchContainer.appendChild(switchBtn);
  }
}

async function handleSwitchChoice(choiceIndex, gameData) {
  let playerTeamIndex = -1;
  for (let i = 0; i < gameData.teams.length; i++) {
    if (gameData.teams[i].members.includes(playerName)) {
      playerTeamIndex = i;
      break;
    }
  }
  
  if (playerTeamIndex === -1) {
    minigameFeedback.innerHTML = '<div class="error">Error: Could not find your team!</div>';
    return;
  }

  const switches = switchContainer.querySelectorAll('.switch');
  switches.forEach(sw => {
    sw.onclick = null;
    sw.disabled = true;
  });
  
  const clickedSwitch = switches[choiceIndex];
  clickedSwitch.style.backgroundColor = "#ffc107";
  clickedSwitch.textContent = "‚úÖ Chosen!";
  
  try {
    const gameRef = ref(db, GAME_ROOM);
    await safeFirebaseOperation(async () => {
      await update(gameRef, {
        [`teamChoices/${playerTeamIndex}`]: {
          switchIndex: choiceIndex,
          playerName: playerName,
          timestamp: Date.now()
        }
      });
    }, "Failed to record choice");
    
    minigameFeedback.innerHTML = '<p>Choice locked in! Waiting for other teams...</p>';
    
  } catch (error) {
    console.error("Error recording switch choice:", error);
    minigameFeedback.innerHTML = `<div class="error">Error recording choice: ${error.message}</div>`;
    
    switches.forEach((sw, index) => {
      sw.onclick = () => handleSwitchChoice(index, gameData);
      sw.disabled = false;
    });
  }
}

// Error handling
window.addEventListener('error', (event) => {
  console.error('JavaScript Error:', event.error);
  const errorMessage = `Unexpected error: ${event.error.message}`;
  
  if (role === "teacher") {
    teacherStatus.innerHTML = `<div class="error">${errorMessage}</div>`;
  } else {
    const currentFeedback = currentView === "minigame" ? minigameFeedback : feedbackEl;
    currentFeedback.innerHTML = `<div class="error">${errorMessage}</div>`;
  }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  cleanupListeners();
});

</script>
</body>
</html>
